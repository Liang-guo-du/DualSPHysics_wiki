This section presents how to start using DualSPHysics:
- [5.1 Pre-requisites: Before you run](#51-pre-requisites--before-you-run)
- [5.2 Directory Structure](#52-directory-structure)
  * [5.2.1 Overview](#521-overview)
  * [5.2.2 Examples](#522-examples)
  * [5.2.3 Format files](#523-format-files)
  * [5.2.4 XML File](#524-xml-file)
  * [5.2.5 BINARY File](#525-binary-file)
  * [5.2.5 VTK File](#525-vtk-file)
- [5.3 Running the DualSPHysics Code](#53-running-the-dualsphysics-code)
  * [5.3.1 Overview of DualSPHysics Workflow](#531-overview-of-dualsphysics-workflow)
  * [5.3.2 Running an example case on Windows](#532-running-an-example-case-on-windows)
  * [5.3.3 Running an example case on Linux](#533-running-an-example-case-on-linux)
- [5.4 Preprocessing](#54-preprocessing)
  * [5.4.1 TO RUN GENCASE from command line:](#541-to-run-gencase-)
- [5.5 Processing](#55-processing)
  * [5.5.1 TO RUN DUALSPHYSICS from command line](#551-to-run-dualsphysics-)
- [5.6 Postprocessing](#56-postprocessing)
  * [5.6.1 Visualization of particle output data (PartVTK)](#561-visualization-of-particle-output-data--partvtk-)
  * [5.6.2 Visualization of boundaries (BoundaryVTK)](#562-visualization-of-boundaries--boundaryvtk-)
  * [5.6.3 Analysis of numerical measurements (MeasureTool)](#563-analysis-of-numerical-measurements--measuretool-)
  * [5.6.4 Force computation (ComputeForces)](#564-force-computation--computeforces-)
  * [5.6.5 Analysis of floating data (FloatingInfo)](#565-analysis-of-floating-data--floatinginfo-)
  * [5.6.6 Surface representation (IsoSurface)](#566-surface-representation--isosurface-)
  * [5.6.7 Flow rate computation (FlowTool)](#567-flow-rate-computation--flowtool-)
  * [5.6.8 Visualisation using Blender](#568-visualisation-using-blender)
- [5.7 Graphical User Interface](#57-graphical-user-interface)

<small><i><a href='http://ecotrust-canada.github.io/markdown-toc/'>Table of contents generated with markdown-toc</a></i></small>


## 5.1 Pre-requisites: Before you run

To run DualSPHysics on a GPU using an executable, only an Nvidia CUDA-enabled GPU card is needed and the latest version of the GPU driver must be installed. 
## 5.2 Directory Structure

### 5.2.1 Overview


The user can download the package from [http://dual.sphysics.org/index.php/downloads/](http://dual.sphysics.org/index.php/downloads/).

Figure 5-1 shows the structure of the content of **DualSPHysics_v5.0.**

<p align="center">
<img width="400px" src="https://i.imgur.com/7dbzHFy.png"/> 
</p>

<p align="center">
<strong>Figure 5-1.</strong> Directory tree of the DualSPHysics v5.0 package.
</p>

**bin:**
* Contains the binaries executables for **linux** and **windows**. 
* Some libraries needed for the codes are also included.

**doc:**
* The folder **guides** contains the following PDF files:
  * DualSPHysics_v5.0_GUIDE is now this WIKI.
  * DualSPHysics_v4.0_LiquidGas_GUIDE.pdf
  * XML_v5.0_GUIDE.pdf: Helps to create a new case using the input XML with explanation of the parameters.
  * ExampleCodeModification_Lisbon2018.pdf: It is a copy of the presentation "Developing on DualSPHysics: examples on code modification and extension" by O. García-Feal given at the 4th DualSPHysics Users Workshop 2018 that shows how to add new functionalities.
  * PostprocessingCalculations_v5.0.pdf: Explains how numerical magnitudes are computed.
  * ExternalModelsConversion_GUIDE.pdf: Describes how to convert the file format of any external geometry of a 3-D model to VTK, PLY or STL using open-source codes.

 * The folder **help** contains files with description of the execution parameters of the different codes is presented in HELP_Code.out and templates of positions of points to be used with MeasureTool (FilePointsTemplate.txt, FilePointsPosTemplate.csv) and how to create domains with FlowTool (FileBoxesTemplate.txt) codes.
 * The folder **xml_format** contains CaseTemplate.xml, an XML with all the different labels and formats that can be used in the input file. It also contains the _FmtXML_XXX.xml files that are examples of the format and options of some special functionalities in XML (such as damping, wave paddles, coupling with Chrono and with MoorDyn, etc.).

**examples:**
 * This directory contains examples of working cases. Each CASE directory includes input XML, batch scripts to execute the cases and additional files to be used for DualSPHysics code. The output files will be created in the same directory. 
 * The **main** examples will use the DualSPHysics_v5.0 executables.
 * The examples in **chrono** use the coupling of DualSPHysics with [Project Chrono](https://projectchrono.org/) library.
 * The examples in **moordyn** use the coupling of DualSPHysics with [MoorDyn+](https://github.com/imestevez/MoorDynPlus) library.
 * The examples in **wavecoupling** show how to use information from other wave propagation models.
 * The examples in **inletoutlet** show how to use new open boundaries (inlet and outlet conditions).
 * The examples in **mdbc** show how to use the new modified Dynamic Boundary Conditions (mDBC).
 * The examples in **twophases** will use the multiphase codes.
 * The **motion** folder contains the scripts to perform examples with the different type of movements that can be described within DualSPHysics.
* In addition, the **others** folder include examples of some advanced options of pre-processing or specific execution options.

**src:**
 * The folder **source** contains the source files of v5.0 (.cpp, .cu and .h). The makefile of linux and the text file for CMAKE.txt are also included in this folder.
 * Visual studio (Community 2015) project for windows can be found in **VS**.
 * The libraries (_.a_ and _.lib_) necessary for compilation are included in **lib**.

**src_extra:**
 * The release includes not only the source files of DualSPHysics v5.0 but also the source files of a code named “ToVTK4”. This code is provided to show how to load particle data, how to read .bi4 files and how to create .vtk or .csv files.

**src_twophases:**
 * The source files of the of DualSPHysics_v4.0_LiquidGas are included here.

### 5.2.2 Examples

Figure 5-2 shows a detailed list of the testcases in the subfolder **examples**

<p align="center">
<img width="400px" src="https://i.imgur.com/tRMvV9B.png"/>   
</p>

<p align="center">
<strong>Figure 5-2.</strong> Directory tree of the "examples" folder of the DualSPHysics v5.0 package.
</p>

### 5.2.3 Format files

The codes provided within the DualSPHysics package present some important
improvements in comparison to the codes available within SPHysics. One of them is
related to the format of the files that are used as input and output data throughout the
execution of DualSPHysics and the pre-processing and post-processing codes. Different
format files for the input and the output data are involved in the DualSPHysics
execution: XML, binary and VTK-binary.

### 5.2.4 XML File

The XML (EXtensible Markup Language) is a textual data format that can easily be read
or written using any platform and operating system. It is based on a set of labels (tags)
that organise the information and can be loaded or written easily using any standard text
or dedicated XML editor. This format is used for input files for the code.

### 5.2.5 BINARY File
The output data in the SPHysics code was written in text files, so ASCII format is used. ASCII files present some interesting advantages such as visibility and portability, however they also present important disadvantages particularly with simulations with large numbers of particles: data stored in text format consumes at least six times more memory than the same data stored in binary format, precision is reduced when values are converted from real numbers to text while reading and writing data in ASCII is more expensive (two orders of magnitude). Since DualSPHysics allows performing simulations with a high number of particles, a binary file format is necessary to avoid these problems. Binary format reduces the volume of the files and the time dedicated to generate them.  These files contain the information of particle properties. In this way, some variables can be removed, e.g., the pressure is not stored since it can be calculated starting from the density using the equation of state. The mass values are constant for fluid particles and for boundaries so only two values are used instead of an array. Data for particles that leave the limits of the domain are stored in an independent file (PartOut_000.obi4) which leads to an additional saving. Hence, the advantages can be summarised as: (i) memory storage reduction, (ii) fast access, (iii) no precision lost and (iv) portability (i.e. to different architectures or different operating systems).

The file format used since DualSPHysics v4.0 is named BINX4 (.bi4) which is the new binary format and can save particle position in single or double precision. This format file is a container so the user can add new metadata and new arrays can be processed in an automatic way using the current post-processing tools of the package.

### 5.2.5 VTK File
VTK (Visualization ToolKit) files are used for final visualization of the results and can either be generated as a pre-processing step or output directly by DualSPHysics instead of the standard BINX format (albeit at the expense of computational overhead). VTK not only supports the particle positions, but also physical quantities that are obtained numerically for the particles involved in the simulations. VTK supports many data types, such as scalar, vector, tensor, texture, and also supports different algorithms such as polygon reduction, mesh smoothing, cutting, contouring and Delaunay triangulation. The VTK file format consists of a header that describes the data and includes any other useful information, the dataset structure with the geometry and topology of the dataset and its attributes. Here VTK files of POLYDATA type with legacy-binary format is used. This format is also easy for input-output (IO) or read-write operations.
VTK format is supported for many visualization applications, such as ParaView that is open-source and multi-platform (https://www.paraview.org/).

## 5.3 Running the DualSPHysics Code

### 5.3.1 Overview of DualSPHysics Workflow

Figure 5-3 shows the workflow with representative example input and output files of the executable files. This figure will be used later to explain in detail each of the codes and the main tools.

<p align="center">
<img width="500px" src="https://imgur.com/snuQHKG.png"/>
</p>
<p align="center">
<img src="https://imgur.com/Pi4thsj.png"/>
</p>

<p align="center">
<strong>Figure 5-3.</strong> Workflow of DualSPHysics v5.0.
</p>

### 5.3.2 Running an example case on Windows

As mentioned before, each “example” directory includes batch scripts that can be used to run all the previous workflow shown in Figure 5-4. This batch files include the following steps:

1. The paths of the pre-processing, processing and post-processing tools are defined 
2. The name of the output folder is created using the name of the case.
3. GenCase is executed: this pre-processing tool creates the initial state of the particles (position, velocity and density) and defines the different SPH parameters for the simulation 
4. DualSPHysics is executed once the case was created with GenCase. The SPH solver is used to solve the fluid-fluid, fluid-solid and solid-solid interactions in order to define the time evolution of the system. Output files with state of the particles are stored in the output folder. By default, binary format is used.
5. Once the simulation is finished, different post-processing tools can be used to convert the binary output files into other formats to analyse the results (VTK, CSV…). Therefore, these post-processing codes are used to visualise the simulation or to compute magnitudes of interest (vorticity, surface elevation, forces, overtopping…).

<p align="center">
<img src="https://i.imgur.com/5DShKzg.png"/>
</p>

<p align="center">
<strong>Figure 5-4.</strong> Example of Case.bat (windows).
</p>

### 5.3.3 Running an example case on Linux

<p align="center">
<strong>Figure 5-5.</strong> Example of Case.sh (linux).
</p>

## 5.4 Preprocessing 

A program named **GenCase** is included to define the initial configuration of the simulation, movement description of moving objects and the parameters of the execution in DualSPHysics. All this information is contained in a definition **input file** in XML format; **Case_Def.xml**. Two **output files** are created after running GenCase: **Case.xml** and **Case.bi4** (the input files for DualSPHysics code). These input (red boxes) and output files (blue boxes) can be observed in Figure 5-6. **Case.xml** contains all the parameters of the system configuration and its execution such as key variables (smoothing length, reference density, gravity, coefficient to calculate pressure, speed of sound…), the number of particles in the system, movement definition of moving boundaries and properties of moving bodies. **Case.bi4** contains the initial state of the particles (number of particles, position, velocity and density) in BINX4 (.bi4) format. Particle geometries created with **GenCase** can be initially checked by visualising in Paraview the files **Case_All.vtk**, **Case_Bound.vtk** and **Case_Fluid.vtk**. Note that **Case_MkCells.vtk** contains planes that represent sets of all particles (grouped with the same mk) with the advantage that this file is one thousand times less heavy to easily visualise huge cases.

<p align="center">
<img src="https://i.imgur.com/qrEyGFl.png" width="450px" />
</p>

<p align="center">
<strong>Figure 5-6.</strong> Input (red) and output (blue) files of GenCase code.
</p>

GenCase employs a 3-D Cartesian mesh to locate particles. The idea is to build any object using particles. These particles are created at the nodes of the 3-D Cartesian mesh. Firstly, the mesh nodes around the object are defined and then particles are created only in the nodes needed to draw the desired geometry. Figure 5-7 illustrates how this mesh is used; in this case a triangle is generated in 2D. First the nodes of a mesh are defined starting from the maximum dimensions of the desired triangle, then the edges of the triangle are defined and finally particles are created at the nodes of the Cartesian mesh which are inside the triangle.

<p align="center">
<img src="https://i.imgur.com/2tCsqNX.jpg" />
</p>

<p align="center">
<strong>Figure 5-7.</strong> Generation of a 2-D triangle formed by particles using GenCase.
</p>

All particles are placed over a regular Cartesian grid. The geometry of the case is defined independently to the inter-particle distance. This allows the discretization of each test case with a different number of particles simply by varying the resolution (or particle size) _dp_. Furthermore, **GenCase** is very fast and able to generate millions of particles only in seconds on the CPU.  

Very complex geometries can be easily created since a wide variety of commands (labels in the XML file) are available to create different objects; points, lines, triangles, quadrilateral, polygons, pyramids, prisms, boxes, beaches, spheres, ellipsoids, cylinders, waves (`<drawpoint />, <drawpoints />, <drawline />, <drawlines />, <drawtriangle />, <drawquadri />, <drawtrianglesstrip />, <drawtrianglesfan />, <drawpolygon>, <drawtriangles />, <drawpyramid  />, <drawprism />, <drawbox />, <drawbeach />, <drawsphere />, <drawellipsoid />, <drawcylinder />, <drawwave />`).

Once the mesh nodes that represent the desired object are selected, these points are stored as a matrix of nodes. The shape of the object can be transformed using a translation (`<move />`), a scaling (`<scale />`) or a rotation (`<rotate />`, `<rotateline />`). With the generation process creating particles at the nodes, different types of particles can be created; a fluid particle (`<setmkfluid />`), a boundary particle (`<setmkbound />`) or none (`<setmkvoid />`). Hence, **mk** is the marker value used to mark a set of particles with a common feature in the simulation. Note that values of the final **mk** are different to **mkfluid**, **mkbound** and **mkvoid** following the rules:

**mk** for boundaries = **mkbound** + **fluidcount** (usually fluidcount=9)

**mk** for fluid particles = **mkfluid** + 1

Particles can be created only at the object surface (`<setdrawmode mode="face" />`), or only inside the bounds of the objects (`<setdrawmode mode="solid" />`) or both (`<setdrawmode mode="full" />`). 

The set of fluid particles can be labelled with features or special behaviours (`<initials />`). For example, initial velocity (`<velocity />`) can be imposed for fluid particles or a solitary wave can be defined (`<velwave />`). Furthermore, particles can be defined as part of a floating object (`<floatings />`). 

Once boundaries are defined, filling a region with fluid particles can be easily obtained using the following commands: (`<fillpoint />`, `<fillbox />`, `<fillfigure />`, `<fillprism />`). This works also in the presence of arbitrarily complex geometries.    

In cases with more complex geometries, external objects can be imported from 3DS files (Figure 5-8) or CAD files (Figure 5-9). This enables the use of realistic geometries generated by 3D designing application with the drawing commands of GenCase to be combined. These files (3DS or CAD) must be converted to STL format (`<drawfilestl />`), PLY format (`<drawfileply />`) or VTK format (`<drawfilevtk />`), formats that are easily loaded by **GenCase**. Any object in STL, PLY or VTK (_object.vtk_, _object.stl_ or _object.ply_ in Figure 9-1) can be split in different triangles and any triangle can be converted into particles using the **GenCase** code.

<p align="center">
<img src="https://i.imgur.com/QRY2q4G.png" width="500px" />
</p>

<p align="center">
<strong>Figure 5-8.</strong> Example of a 3D file imported by GenCase and converted into particles.
</p>

<p align="center">
<img src="https://i.imgur.com/VqskWxQ.png" width="500px"/>
</p>

<p align="center">
<strong>Figure 5-9.</strong> Example of a CAD file imported by GenCase and converted into particles.
</p>

Different kinds of movements can be imposed to a set of particles; linear, rotational, circular, sinusoidal, etc. To help users define movements, a directory with some examples is also included in the DualSPHysics package. Thus, the directory **DualSPHysics_v5.0/examples/motion** includes:
* Motion01: uniform rectilinear motion (`<mvrect />`) that also includes pauses (`<wait />`) 
* Motion02: combination of two uniform rectilinear motion (`<mvrect />`)
* Motion03: movement of an object depending on the movement of another (hierarchy of objects)
* Motion04: accelerated rectilinear motion (`<mvrectace />`)
* Motion05: rotational motion (`<mvrot />`). See Figure 9-5.
* Motion06: accelerated rotation motion (`<mvrotace />`) and accelerated circular motion (`<mvcirace />`). See Figure 5-10.
* Motion07: sinusoidal movement (`<mvrectsinu />`, `<mvrotsinu />`, `<mvcirsinu />`)
* Motion08: prescribed with data from an external file (time, position) (`<mvfile/>`)
* Motion09: prescribed with data from an external file (time, angle) (`<mvrotfile />`)

<p align="center">
<img src="https://i.imgur.com/NBHRPLe.png" width="400px"/>
</p>

<p align="center">
<strong>Figure 5-10.</strong> Example of rotational motion.
</p>

<p align="center">
<img src="https://i.imgur.com/DQtKQxs.png" width="400px" />
</p>

<p align="center">
<strong>Figure 5-11.</strong> Example of accelerated rotation motion and accelerated circular motion.
</p>

Please, note that there are two versions of the GenCase code:
* GenCase_win64.exe / GenCase5_linux64
* GenCase5_MkWord_win64.exe / GenCase5_MkWord_linux64
GenCase5_MkWord_win64 allows the user to create up to 65000 floating or solid objects while GenCase_win64 allows to create only 240 objects, but it is faster and needs 50% less memory, so that, it is suitable for cases with large number of particles.

### 5.4.1 TO RUN GENCASE: 
### example: `GenCase Case_Def Case [options]`
where _Case_Def_ is the name of the input file (Case_Def.xml as seen in Figure 5-12) and Case will be the name of the output files (Case.xml and Case.bi4) and the _options _are:

**-h**
Shows information about the different parameters. Typing “GenCase –h” in the command window generates a brief help manual (available in **doc/help** folder).

**-ver**
Shows version information

**-template**
Generates the example file CaseTemplate.xml that is already generated and saved in doc/xml_format folder.

**-dp:[float]**
Defines the distance between particles. By varying this parameter the number of particles will be modified without changing any other data since all dimensions are given in global dimensions.

**-ompthreads:[int]**  
Indicates the number of threads by host for parallel execution, it takes the number of cores of the device by default (or using zero value).

**-save:[values]**
Indicates the format of output files. 
* +/-**all**: To choose or reject all options
* +/-**bi**: Binary format for the initial configuration (by default)
* +/-**vtkall**: VTK with all particles of the initial configuration
* +/-**vtkbound**: VTK with boundary particles of the initial configuration
* +/-**vtkfluid**: VTK with fluid particles of the initial configuration

Note that when using –save:all, the files **Case_All.vtk**, **Case_Bound.vtk** and **Case_Fluid.vtk** of Figure 9-1 are also generated and should be visualised to check the generated particles before launching the simulation.

**-debug:[int]**
Debug level (-1:Off, 0:Explicit, n:Debug level)

**-createdirs:[0/1]**
Creates full path for output files (value by default is read from DsphConfig.xml or 1)

**Examples:**
* `GenCase4 citydef city` (_“citydef” is the name of the input file and “city” is the name of the output files_)
* `GenCase4 case case -dp:0.01` (_“case” is the name of the input file and “case” is also the name of the output files, but “dp” is changed_)

A more complete description of the code and the XML files can be found in **XML_v5.0_GUIDE.pdf** available in **DualSPHysics_v5.0/doc/guides**. This document helps to create a new case using the input XML file and all XML parameters are explained and related to SPH equations.

An example of input XML is shown here; the CaseWavemaker_Def.xml included in **DualSPHysics_v5.0/examples/main/06_Wavemaker**:

<p align="center">
<img src="https://i.imgur.com/vKw4Vtt.png"/>
</p>

<p align="center">
<strong>Figure 5-11.</strong> Content of CaseWavemaker_Def.xml.
</p>

## 5.5 Processing 

The main code which performs the SPH simulation is named **DualSPHysics**.

The **input files** to run DualSPHysics code include one XML file (**Case.xml** in Figure 5-12) and a binary file (**Case.bi4** in Figure 5-12). **Case.xml** contains all the parameters of the system configuration and its execution such as key variables (smoothing length, reference density, gravity, coefficients to compute pressure starting from density, speed of sound…), the number of particles in the system, movement definition of moving boundaries and properties of moving bodies. The binary file **Case.bi4** contains the particle data; arrays of position, velocity and density and headers. The **output files** consist of; i) binary format files with the particle information at different instants of the simulation (**Part0000.bi4, Part0001.bi4, Part0002.bi4** …), ii) file with excluded particles (**PartOut.obi4**), iii) file with basic information to execute the post-processing tools (**Part_Head.ibi4**), iv) file with information of the floating objects (**PartFloat.fbi4**), and v) text file with execution log (**Run.out**).

<p align="center">
<img src="https://i.imgur.com/H875PR4.png"/>
</p>

<p align="center">
<strong>Figure 5-12.</strong> Input (red) and output (blue) files of DualSPHysics code.
</p>

Different parameters defined in the XML file can be be changed using executions parameters of DualSPHysics: time stepping algorithm specifying Symplectic or Verlet (**`-symplectic, -verlet[:steps]`**), choice of kernel function which can be Cubic, Wendland or Gaussian (**`-cubic, -wendland, -gaussian`**), the value for artificial viscosity (**`-viscoart: <float>`**) or laminar+SPS viscosity treatment (**`-viscolamsps:<float>`**), activation of the Delta-SPH formulation (**`-deltasph: <float>`**), use of shifting algorithm (**`-shifting: <mode>`**) the maximum time of simulation and time intervals to save the output data (**`-tmax:, -tout:`**). To run the code, it is also necessary to specify whether the simulation is going to run in CPU or GPU mode (**`-cpu, -gpu[:id]`**), the format of the output files (**`-sv:[formats,...], none, binx, ascii, vtk, csv`**), that summarises the execution process (**`-svres:<0/1>`**) with the computational time of each individual process (**`-svtimers:<0/1>`**). It is also possible to exclude particles as being out of limits according to prescribed minimum and maximum values of density (**`-rhopout:min:max`**) or that travel further than maximum Z position (**`-incz:<float>`**).

For CPU executions, a multi-core implementation using OpenMP enables executions in parallel using the different cores of the machine. It takes the maximum number of cores of the device by default or users can specify it (**`-ompthreads:<int>`**). On the other hand, different cell divisions of the domain can be used (**`-cellmode:<mode>`**) that differ in memory usage and efficiency. 

DualSPHysics uses double precision for variables of position of the particles (**`-posdouble:<mode>`**) for the computation of particle interactions. The particle interaction is one of the most time-consuming parts of the simulation, hence the precision in this part can be controlled using the **`-posdouble`** parameter, which takes the following values:
0: particle interaction is performed using single precision for position variables (_x, y, z_) 
When “dp” is much smaller than size of the domain, the user is recommended to choose one of the following:

1. particle interaction is performed using double precision for position variables but final position is stored using simple precision
2. particle interaction is performed using double precision for position variables and final position is stored using double precision.

An important novelty since v4.0 is the determination of the optimum BlockSize for the CUDA kernels that execute particle interaction (**`-blocksize:<mode>`**):
* Fixed (`-blocksize:0`): A fixed block size of 128 threads is used. This value does not always provide the maximum performance but it usually offers good performance for those type of kernels.
* Occupancy (`-blocksize:1`): Occupancy Calculator of CUDA is used to determine the optimum block size according to the features of the kernel (registers and shared memory, however data used in the kernels are not considered). This option is available from CUDA 6.5
* Empirical (`-blocksize:2`): Here, data used in the CUDA kernels is also considered. The optimum BlockSize is evaluated every certain number of steps (500 by default). In this way, block size can change during the simulation according to input data. 

Please, note that there are two versions of the DualSPHysics code:
* DualSPHysics5.0_win64.exe / DualSPHysics5.0_linux64
* DualSPHysics5.0CPU_win64.exe / DualSPHysics5.0CPU_linux64
The second one was compiled to be executed only on CPU, while the first one includes GPU or CPU execution.

### 5.5.1 TO RUN DUALSPHYSICS: 
### example: `DualSPHysics Case [options]`
where _Case_ is the name of the input files (Case.xml & Case.bi4 as seen in Figure 5-12).

`$dualsphysics $dirout/$name $dirout -svres –cpu`
enables the simulation on the cpu, where $dirout is the directory with the file $name.bi4

`$dualsphysics $dirout/$name $dirout -svres –gpu`
enables the same simulation on the gpu.

`$dualsphysics $dirout/$name $dirout -svres –gpu –partbegin:69 dirbegin`
restarts the simulation from the time corresponding to files output Part0069.bi4 located in the directory dirbegin

The configuration of the execution is mostly defined in the XML file, but it can be also defined or changed using **execution parameters**. Furthermore, new options and possibilities for the execution can be imposed using **[options]**:

**-h** Shows information about parameters. Typing “DualSPHysics –h” in the command window generates a brief help manual (available in pdf/help folder).

**-ver** Shows version information

**-opt[file]** Loads configuration from a file.

**-cpu** Execution on CPU (option by default).

**-gpu[:id]** Execution on GPU and id of the device.

**-stable** Ensures the same results when a simulation is repeated since operations are always carried out in the same order. 

**-posdouble:[mode]** Precision used in position for particle interactions
* **0** Use and store in single precision (option by default)
* **1** Use double precision but saves result in single 
* **2** Use and store in double precision

**-ompthreads:[int]** Only for CPU. Indicates the number of threads by host for parallel execution, this takes the number of cores of the device by default (or using zero value).

**-blocksize:[mode]** Defines BlockSize to use in particle interactions on GPU
 * **0** Fixed value (128) is used (option by default)
 * **1** Optimum BlockSize indicated by Occupancy Calculator of CUDA
 * **2** Optimum BlockSize is calculated empirically 

**-cellmode:[mode]** 
Specifies the cell division mode, by default, the fastest mode is chosen 
        2h       lowest and the least expensive in memory 
        h         fastest and the most expensive in memory

**-symplectic** Symplectic algorithm as time step algorithm.

**-verlet[:steps]** Verlet algorithm as time step algorithm and number of time steps to switch equations.

**-cubic** Cubic spline kernel.

**-wendland** Wendland kernel.

**-gaussian** Gaussian kernel

**-viscoart:[float]** Artifitical viscosity [0-1].

**-viscolamsps:[float]** Laminar+SPS viscosity [order of 1E-6].

**-viscoboundfactor:[float]** Multiplies the viscosity value of boundary.

**-deltasph:[float]** Constant for DeltaSPH. Typical value is 0.1 (0 by default)

**-shifting:[mode]** Specifies the use of Shifting correction
 * **none** Shifting is disabled (by default)
 * **nobound** Shifting is not applied near boundary
 * **nofixed** Shifting is not applied near fixed boundary
 * **full** Shifting is always applied

-sv:[formats,...] Specifies the output formats:
 * **none** No particles files are generated
 * **binx** Binary files (option by default)
 * **info** Information about execution in .ibi4 format
 * **vtk** VTK files
 * **csv** CSV files

**-createdirs:[0/1]** Creates full path for output files (value by default is read from DsphConfig.xml or 1)

**-csvsep:[0/1]** Separator character in CSV files (0=semicolon, 1=coma) (value by default is read from DsphConfig.xml or 0)

**-svres:[0/1]** Generates file that summarises the execution process.

**-svtimers:[0/1]** Obtains timing for each individual process.

**-svdomainvtk:[0/1]** Generates VTK file with domain limits.    
 
**-name [string]** Specifies path and name of the case.   

**-runname [string]** Specifies name for case execution.

**-dirout [dir]** Specifies the output directory. 

**-dirdataout [dir]** Specifies the output subdirectory for binary data

**-partbegin:begin[:first] dir** RESTART option. Specifies the beginning of the simulation starting from a given PART (begin) and located in the directory (dir), (first) indicates the number of the first PART to be generated.

**-incz:[float]** Allows increase in Z+ direction of the computational domain. Case domain is fixed as function of the initial particles, however the maximum Z position can be increased with this option in case particles reach higher locations.

**-rhopout:min:max** Excludes fluid particles out of these density limits.

**-ftpause:[float]** Time to start floating bodies movement. By default 0.

**-tmax:[float]** Maximum time of simulation.

**-tout:[float]** Time between output files.

**-domain_particles[:xmin,ymin,zmin,xmax,ymax,zmax]** The domain is fixed as a function of the initial article positions and modified for xmin,...    

**-domain_particles_prc:xmin,ymin,zmin,xmax,ymax,zmax** The values in proportion with the case dimensions according to the initial particles.

**-domain_fixed:xmin,ymin,zmin,xmax,ymax,zmax** The domain is fixed  with the specified values.

**Examples:**

`DualSPHysics5 -gpu case out_case -sv:binx,csv` (_"-cpu" to be executed on CPU, “case” is the name of the input files, “out_case” is the output directory, that should already exists and the option “-sv:binx,csv” specifies those output formats_)

`DualSPHysics5 -gpu -name case -dirout out_case -sv:binx,csv` (_"-cpu" to be executed on GPU, “case” is the name of the input files, “out_case” is the output directory and the option “-sv:binx” specifies that output format_)

### FILE Run.out:
This text file contains the execution log:
 * Execution device
 * List with values of the simulation parameters 
 * Information when output files are created (including estimated finish time)
 * Resume of the simulation (runtimes, number of steps, excluded particles…)
 * List of the generated files and information about their content
 * Collection of warnings displayed during execution (about excluded particles or when time-step value reaches the lower limit) 

## 5.6 Postprocessing 

### 5.6.1 Visualization of particle output data (PartVTK)

The **PartVTK** code is used to convert the output binary files of DualSPHysics into different formats that can be visualised and /or analysed. Thus, the output files of DualSPHysics, the binary files (.bi4), are now the **input files** for the post-processing code **PartVTK**. 

<p align="center">
<img src="https://i.imgur.com/4fwkz35.png" />
</p>

<p align="center">
<strong>Figure 5-13.</strong> Input (red) and output (blue) files of PartVTK code.
</p>

The **output files** can be VTK-binary (`-savevtk`), CSV (`-savecsv`) or ASCII (`-saveascii`). In this way the results of the simulation can be plotted using Paraview, gnuplot, Octave, etc…. For example; PartVtkBin_0000.vtk,... These files can be generated by selecting a set of particles defined by **mk** (`-onlymk:`), by the id of the particles (`-onlyid:`), by the type of the particle (`-onlytype:`), by the position of the particles (`-onlypos:` and `-onlyposfile`) or by the limits of velocity of the particles (`-onlyvel:`),  so we can choose to include or not include all the particles (`+/-all`), the boundaries (`+/-bound`), the fixed boundaries (`+/-fixed`), the moving boundaries (`+/-moving`), the floating bodies (`+/-floating`) or the fluid particles (`+/-fluid`). The output files can contain different particle data (`-vars:`); all the physical quantities (`+/-all`), velocity (`+/-vel`), density (`+/-rhop`), pressure (`+/-press`), mass (`+/-mass`), volume (`+/-vol`), acceleration (`+/-ace`), vorticity (`+/-vor`), the id of the particle (`+/-idp`), the mk of the particle (`+/-mk`) and the type (`+/-type:`). The user can define new variables in DualSPHysics and make reference to those in PartVTK using `-vars:NewVar` or `-vars:all`.
More information can be found in _PartVTK5_Help.out_ in **doc/help**.

In addition, the **PartVTKOut code** is used to generate files with the particles that were excluded from the simulation (stored in **PartOut.obi4**). The output file of DualSPHysics, **PartOut.obi4** is the input file for the post-processing code **PartVTKOut**. Information with excluded particles can be stored in CSV files (`-savecsv: -SaveResume`) and VTK (`-savevtk:`) can be generated with those particles.

<p align="center">
<img src="https://i.imgur.com/AjDAzaU.png" />
</p>

<p align="center">
<strong>Figure 5-14.</strong> Input (red) and output (blue) files of PartVTKOut code.
</p>

Particles can be excluded from the simulation for three reasons:
* POSITION: Limits of the domain are computed starting from particles that were created in **GenCase**. Note that these limits are different from **pointmin **and **pointmax **defined in section <definition> of the input XML and can be also changed by the user when executing **DualSPHysics** code. The actual limits of the domain can be seen in Run.out: MapRealPos(final). Therefore, when one particle moves beyond those limits, the particle is excluded. 
* DENSITY: Valid values of particle density are between RhopOutMin (default=700) and RhopOutMax (default=1300), but the user can also change those values.
* VELOCITY: One particle can be also removed from the system when its displacement exceeds 0.9*Scell during one time step (Scell is the size of the cell).

### 5.6.2 Visualization of boundaries (BoundaryVTK)

In order to visualise the boundary shapes formed by the boundary particles, different geometry files can be generated using the **BoundaryVTK code**. The code creates triangles or planes to represent the boundaries.

As **input data**, shapes can be loaded from a VTK file (`-loadvtk`), a PLY file (`-loadply`) or an STL file (`-loadstl`) while boundary movement can be imported from an XML file (`-filexml file.xml`) using the timing of the simulation (`-motiontime`) or with the exact instants of output data (`-motiondatatime`). The movement of the boundaries can also be determined starting from the particle positions (`-motiondata`, `-motiondata0` for RESTART). The **output files** consist of VTK files (`-savevtk`), PLY files (`-saveply`) or STL files (`-savestl`) with the loaded information and the moving boundary positions at different instants. For example, the output files can be named motion_0000.vtk, motion_0001.vtk, motion_0002.vtk... These files can be also generated by only a selected object defined by **mk** (`-onlymk:`), by the **id** (`-onlyid:`) or by the **type** (`-onlytype:`) of the object.

There is novel functionality that allows the user to save the position of a moving point (or several). Using a new parameter (`-saveposmotion:Mk:x:y:z`), a CSV file is created with the movement of that initial position **x,y,z** but using the motion applied to that **Mk**.

More information can be found in BoundaryVTK5_Help.out in **doc/help**.

<p align="center">
<img src="https://i.imgur.com/JJ6NP93.png" />
</p>

<p align="center">
<strong>Figure 5-15.</strong> Input (red) and output (blue) files of BoundaryVTK code.
</p>

### 5.6.3 Analysis of numerical measurements (MeasureTool)

To compare experimental and numerical values, a tool to analyse these numerical measurements is needed.  The **MeasureTool** code allows different physical quantities at a set of given points to be computed. The binary files (.bi4) generated by DualSPHysics are the **input files** of the MeasureTool code and the **output files** are again VTK-binary or CSV or ASCII. The numerical values are computed by means of an SPH interpolation of the values of the neighbouring particles around a given position (see also PostprocessingCalculations_v5.0.pdf). 

<p align="center">
<img src="https://i.imgur.com/LMs1UML.png" />
</p>

<p align="center">
<strong>Figure 5-16.</strong> Input (red) and output (blue) files of MeasureTool code.
</p>

The interpolation is computed using the Wendland kernel. Kernel correction is also applied when the summation of the kernel values around the position is higher than a value (`-kclimit:`) defining a dummy value if the correction is not applied (`-kcdummy:`). The positions where the interpolation is performed are given in a text file for fixed position (`-points <file>`) or with position that changes in time (`-pointspos <file>`). Variables can be also computed at the position of existing particles with a given mk (`-particlesmk:`) or by indicating their id (`-particlesid:`). The distance of interpolation can be 2h (the size of the kernel) or can be changed (`-distinter_2h:`, `-distinter:`). The interpolation is carried out using a selected set of particles, so the same commands for PartVTK can be used (`-onlymk:`, `-onlyid:`, `-onlytype:`, `-onlypos:`, `-onlyposfile`). Different interpolated variables (`-vars`) can be numerically calculated; all available ones (`+/-all`), velocity (`+/-vel`), density (`+/-rhop`), pressure (`+/-press`), mass (`+/-mass`), volume (`+/-vol`), id (`+/-idp`), vorticity (`+/-vor`), acceleration (`+/-ace`) the summation of the kernel multiplied by volume (`+/-kcorr`), and variables defined by the user (`+/-XXX`). The maximum water depth can be also computed. Height values (`-height:`) are calculated according to the interpolated mass, if the nodal mass is higher than a given reference mass, that Z-position will be considered as the maximum height. The reference value can be calculated in relation to the mass values of the selected particles (`-height:0.5`, half the mass by default in 3D and `-height:0.4`  in 2D) or can be given in an absolute way (`-heightlimit:`).

As mentioned before, the positions where magnitudes will be computed are given in a text file for fixed position or with position that changes in time:
* fixed position using (`-points <file>`) and with a file needs to start with the key words POINTS or POINTSLIST:

<p align="center">
<img src="https://i.imgur.com/IZvS3sq.png" />
</p>

* position that changes in time using (`-pointspos <file>`) and the file should contain different lines with the position of the point of measurement.

Note that **MeasureTool** is looking for the Z-position where there is a change between fluid and void, starting from the lower point defined in POINTSLIST, i.e. BeginZ, and moving upwards. It stops when the nodal oint is higher than a given reference mass.

As shown before there is a novel functionality in **BoundaryVTK** code that allows to create a CSV file with the positions of a moving point during the simulation. That CSV file can be used now with **MeasureTool** (`-pointspos file.csv`).

These points can be modified using a transformation matrix with displacement (MOVE), rotation (ROTATEAXIS) and scaling (SCALE). By default, the identity matrix is applied but using the following commands the matrix can be modified: 

<p align="center">
<img src="https://i.imgur.com/gtLPZRQ.png" />
</p>

More information can be found in MeasureTool5_Help.out in **doc/help**.

### 5.6.4 Force computation (ComputeForces)

The **ComputeForces** code is employed to compute the force exerted by the fluid onto a boundary object. The value of force is calculated as the summation of the acceleration values (solving the momentum equation) multiplied by the mass of each boundary particle (see also PostprocessingCalculations_v4.2.pdf). 

<p align="center">
<img src="https://i.imgur.com/MwiJ02f.png" />
</p>

<p align="center">
<strong>Figure 5-17.</strong> Input (red) and output (blue) files of ComputeForces code.
</p>

The momentum equation to solve the acceleration values is computed using the Wendland kernel. The distance of interpolation can be 2h (the size of the kernel) or can be changed (`-distinter_2h:`, `-distinter:`). The interpolation is carried out using a selected set of particles, so the same commands for PartVTK can be used (`-onlymk:`, `-onlyid:`, `-onlypos:`). The **output files** can be VTK-binary (`-savevtk`), CSV (`-savecsv`) or ASCII (`-saveascii`). 

Note that when computing forces exerted onto a floating body, the force is divided in: a) the force executed by the fluid onto the body, and b) the weight of the body. The total force is also included.  

In addition, the moment about an axis can be also computed by defining the axis using `-momentaxis:x1:y1:z1:x2:y2:z2`. An example of moment computation can be found in examples/main/05_SloshingTank.  

More information can be found in _ComputeForces5_Help.out_ in **doc/help**.

### 5.6.5 Analysis of floating data (FloatingInfo)

The _FloatingInfo_ code is employed to obtain different data of the floating objects such as linear velocity, angular velocity, displacement of the center, motions and angles of rotation. The binary files (.bi4) generated by DualSPHysics and the file PartFloat.fbi4 are the **input files** of the **FloatingInfo** code and the **output files** are CSV files.

<p align="center">
<img src="https://i.imgur.com/riUel6V.png" />
</p>

<p align="center">
<strong>Figure 5-18.</strong> Input (red) and output (blue) files of FloatingInfo code.
</p>

By default, the code always saves time, fvel (linear velocity), fomega (angular velocity), center. Motions and rotation are also obtained (`-savemotion`) in 2D (_surge, heave, pitch_) and in 3D (_surge, sway, heave, roll, pitch, yaw_). A CSV file will be created with the information of each floating in the simulation, but user can choose a given floating object (`-onlymk:`) or the name of the file (`-savedata`).

More information can be found in FloatingInfo5_Help.out in **doc/help**.

### 5.6.6 Surface representation (IsoSurface)

Using a large number of particles, the visualization of the simulation can be improved by representing surfaces instead of particles. To create the surfaces, the _marching cubes_ algorithm is used [Lorensen and Cline, 1987]. This computer graphics technique extracts a polygonal mesh (set of triangles) of an isosurface from a 3-D scalar field. 

Figure 11-7, represents a 3-D dam-break simulation using 300,000 particles. The first snapshot shows the particle representation. Values of mass are interpolated at the nodes of a 3-D Cartesian mesh that covers the entire domain using an SPH interpolation. Thus a 3-D mesh vertex that belongs to the free surface can be identified. The triangles of this surface (generated by means of the marching cubes algorithm) are represented in the second frame of the figure. The last snapshots correspond to the surface representation where the colour corresponds to the interpolated velocity value of the triangles.

<p align="center">
<img src="https://i.imgur.com/cjrfEUR.png" />
</p>

<p align="center">
<strong>Figure 5-19.</strong> Conversion of points to surfaces.
</p>

The output binary files of DualSPHysics are the **input files** of the IsoSurface code and the **output files** are VTK files (`-saveiso[:<var>]`) with the isosurfaces calculated using a variable (`<var>`) or can be structured points (`-savegrid`) with data obtained after the interpolation. The Cartesian mesh size can be defined by specifying the discretisation size using either the particle size dp (`-distnode_dp:`) or by specifying an absolute internode distance (`-distnode:`). On the other hand, the maximum distance for the interaction between particles to interpolate values on the nodes can be also defined depending on 2h (`-distinter_dp:`) or in an absolute way (`-distinter:`). The particles to be considered to create the isosurface can be defined by the user using positions (`-onlypos` & `-onlyposfile`) or the limits of the isosurface can be indicated (`-iso_limits:`).

In addition, a useful option is to save a VTK file (polydata) with the slice of the isosurface (`-saveslice <file.vtk>`). The user can indicate how the vertices are processed to create the slice (`-slicedata:`). The plane of the slice can be also defined using a point and a vector (`-slicevec:ptx:pty:ptz:vecx:vecy:vecz`), or using three points (`-slice3pt:pt1x:pt1y:pt1z:pt2x:pt2y:pt2z:pt3x:pt3y:pt3z`).
This option can be interesting in 3-D tests, but it is very useful in 2D where contour lines of the fluid can be represented without plotting all fluid particles.

More information can be found in _IsoSurface5_Help.out_ in **doc/help**.

<p align="center">
<img src="https://i.imgur.com/QNKl1fc.png" />
</p>

<p align="center">
<strong>Figure 5-20.</strong> Input (red) and output (blue) files of IsoSurface code.
</p>

### 5.6.7 Flow rate computation (FlowTool)

The **FlowTool** code calculates the number of fluid particles that enters or leaves domains defined by the user. The average velocity of the particles that enters that domain since last output time is also computed. With the number of particles in the domain, the volume can be easily calculated by multiplying the volume of one particle by the number of particles. Therefore, the volume of fluid in some defined domains can be used to determine the inflow and outflow by dividing it with the interval time (output time). This post-processing tool is therefore very useful to compute discharges or overtopping in the case of coastal protection. 

The output binary files of DualSPHysics are the **input files** of the FlowTool code and **output files** can be VTK-binary (`-savevtk`) or CSV (`-savecsv`). The VTK (polydata) files contains the particles at the different domains and the CSV contains the number of particles that enters and leaves the domains (each specified by the user but also the entire system), the average velocity of those particles, the changes in volume and the inflow and outflow. 

<p align="center">
<img src="https://i.imgur.com/Py4QjYK.png" />
</p>

<p align="center">
<strong>Figure 5-21.</strong> Input (red) and output (blue) files of FlowTool code.
</p>

The domains are specified by the user (`-fileboxes`) using a text file where the 8 vertexes of a prism are defined:

<p align="center">
<img src="https://i.imgur.com/iCwbh0M.png" />
</p>

There is also an option to create a template file that helps the user (`-boxestemplate`).
More information can be found in _FlowTool5_Help.out_ in **doc/help**.

Figure 5-22 includes an example where three different prisms (the red, green and yellow domains) were defined. The discharge into the red box was computed (Figure 11-11) using the number of particles that enter the domain.

<p align="center">
<img src="https://i.imgur.com/6Dxi6YJ.png" />
</p>

<p align="center">
<strong>Figure 5-22.</strong> Prisms (the red, green and yellow domains) defined to use FlowTool code. 
</p>

<p align="center">
<img src="https://i.imgur.com/fgGW7PQ.png" />
</p>

<p align="center">
<strong>Figure 5-23.</strong> Time series of the discharge into the red prism.
</p>

### 5.6.8 Visualisation using Blender

[VisualSPHysics](https://github.com/EPhysLab-UVigo/VisualSPHysics) is an add-on for Blender to import DualSPHysics simulations, with this, the user can render realistic images and animations with complex effects. Moreover, VisualSPHysics also features a foam simulator (for visualization purposes only) that works in post-processing.

VisualSPHysics is open-source under GPLv3 license and is available on [GitHub](https://github.com/EPhysLab-UVigo/VisualSPHysics).

<p align="center">
<img src="https://camo.githubusercontent.com/7266a80c0cf9775a1e4b3f81beeb2f8a547038cb/687474703a2f2f6475616c2e73706879736963732e6f72672f626c656e6465722f696d672f73637265656e73686f742e706e67" />
</p>

<p align="center">
<strong>Figure 5-24.</strong> Screenshot of VisualSPHysics software. 
</p>

The animation performed in Figure 5-24 can be seen [here](https://www.youtube.com/watch?v=EvSDFRfJToQ).
 
## 5.7 Graphical User Interface

SPH-based simulations are growing in applicability to solve industrial problems. The use of a friendly interface is key to encourage new users to work with SPH codes. Therefore we have developed a GUI named DesignSPHysics. 

DesignSPHysics is developed as open source software, so that, following the DualSPHysics philosophy, this new tool can be freely downloaded at www.design.sphysics.org. FreeCAD is chosen as the host 3D modelling software for the plug-in due to its multi-platform capability. The implementation of DesignSPHysics was carried out using Python as the default scripting language and QT as its GUI framework. In addition, the background processes, the interface layer and other complex operations are developed with specific multi-platform compatible libraries and methods.

DesignSPHysics is presented as part of the DualSPHysics package, meaning that any user already familiar with the command line interface and XML-driven case generation can easily understand how the GUI works. However, the main objective of DesignSPHysics is that new users, not familiar with DualSPHysics, can create new cases from scratch and run simulations.

<p align="center">
<img src="https://i.imgur.com/eaVjoUK.png" />  
</p>

More information in: https://design.sphysics.org/