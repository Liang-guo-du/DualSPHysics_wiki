## 11.1 Visualization of particle output data (PartVTK)

The **PartVTK** code is used to convert the output binary files of DualSPHysics into different formats that can be visualised and /or analysed. Thus, the output files of DualSPHysics, the binary files (.bi4), are now the **input files** for the post-processing code **PartVTK**. 

<p align="center">
<img src="https://i.imgur.com/4fwkz35.png" />
</p>

<p align="center">
<strong>Figure 11-1.</strong> Input (red) and output (blue) files of PartVTK code.
</p>

The **output files** can be VTK-binary (`-savevtk`), CSV (`-savecsv`) or ASCII (`-saveascii`). In this way the results of the simulation can be plotted using Paraview, gnuplot, Octave, etcâ€¦. For example; PartVtkBin_0000.vtk,... These files can be generated by selecting a set of particles defined by **mk** (`-onlymk:`), by the id of the particles (`-onlyid:`), by the type of the particle (`-onlytype:`), by the position of the particles (`-onlypos:` and `-onlyposfile`) or by the limits of velocity of the particles (`-onlyvel:`),  so we can choose to include or not include all the particles (`+/-all`), the boundaries (`+/-bound`), the fixed boundaries (`+/-fixed`), the moving boundaries (`+/-moving`), the floating bodies (`+/-floating`) or the fluid particles (`+/-fluid`). The output files can contain different particle data (`-vars:`); all the physical quantities (`+/-all`), velocity (`+/-vel`), density (`+/-rhop`), pressure (`+/-press`), mass (`+/-mass`), volume (`+/-vol`), acceleration (`+/-ace`), vorticity (`+/-vor`), the id of the particle (`+/-idp`), the mk of the particle (`+/-mk`) and the type (`+/-type:`). The user can define new variables in DualSPHysics and make reference to those in PartVTK using `-vars:NewVar` or `-vars:all`.
More information can be found in _PartVTK4_Help.out_ in **doc/help**.

In addition, the **PartVTKOut code** is used to generate files with the particles that were excluded from the simulation (stored in **PartOut.obi4**). The output file of DualSPHysics, **PartOut.obi4** is the input file for the post-processing code **PartVTKOut**. Information with excluded particles can be stored in CSV files (`-savecsv: -SaveResume`) and VTK (`-savevtk:`) can be generated with those particles.

<p align="center">
<img src="https://i.imgur.com/AjDAzaU.png" />
</p>

<p align="center">
<strong>Figure 11-2.</strong> Input (red) and output (blue) files of PartVTKOut code.
</p>

Particles can be excluded from the simulation for three reasons:
* POSITION: Limits of the domain are computed starting from particles that were created in **GenCase**. Note that these limits are different from **pointmin **and **pointmax **defined in section <definition> of the input XML and can be also changed by the user when executing **DualSPHysics** code. The actual limits of the domain can be seen in Run.out: MapRealPos(final). Therefore, when one particle moves beyond those limits, the particle is excluded. 
* DENSITY: Valid values of particle density are between RhopOutMin (default=700) and RhopOutMax (default=1300), but the user can also change those values.
* VELOCITY: One particle can be also removed from the system when its displacement exceeds 0.9*Scell during one time step (Scell is the size of the cell).

## 11.2 Visualization of boundaries (BoundaryVTK)

In order to visualise the boundary shapes formed by the boundary particles, different geometry files can be generated using the **BoundaryVTK code**. The code creates triangles or planes to represent the boundaries.

As **input data**, shapes can be loaded from a VTK file (`-loadvtk`), a PLY file (`-loadply`) or an STL file (`-loadstl`) while boundary movement can be imported from an XML file (`-filexml file.xml`) using the timing of the simulation (`-motiontime`) or with the exact instants of output data (`-motiondatatime`). The movement of the boundaries can also be determined starting from the particle positions (`-motiondata`, `-motiondata0` for RESTART). The **output files** consist of VTK files (`-savevtk`), PLY files (`-saveply`) or STL files (`-savestl`) with the loaded information and the moving boundary positions at different instants. For example, the output files can be named motion_0000.vtk, motion_0001.vtk, motion_0002.vtk... These files can be also generated by only a selected object defined by **mk** (`-onlymk:`), by the **id** of the object (`-onlyid:`).

There is novel functionality that allows the user to save the position of a moving point (or several). Using a new parameter (`-saveposmotion:Mk:x:y:z`), a CSV file is created with the movement of that initial position **x,y,z** but using the motion applied to that **Mk**.

More information can be found in BoundaryVTK4_Help.out in **doc/help**.

<p align="center">
<img src="https://i.imgur.com/JJ6NP93.png" />
</p>

<p align="center">
<strong>Figure 11-3.</strong> Figure 11-3. Input (red) and output (blue) files of BoundaryVTK code.
</p>

## 11.3 Analysis of numerical measurements (MeasureTool)

To compare experimental and numerical values, a tool to analyse these numerical measurements is needed.  The **MeasureTool** code allows different physical quantities at a set of given points to be computed. The binary files (.bi4) generated by DualSPHysics are the **input files** of the MeasureTool code and the **output files** are again VTK-binary or CSV or ASCII. The numerical values are computed by means of an SPH interpolation of the values of the neighbouring particles around a given position (see also PostprocessingCalculations_v4.2.pdf). 

<p align="center">
<img src="https://i.imgur.com/LMs1UML.png" />
</p>

<p align="center">
<strong>Figure 11-4.</strong> Input (red) and output (blue) files of MeasureTool code.
</p>

The interpolation is computed using the Wendland kernel. Kernel correction is also applied when the summation of the kernel values around the position is higher than a value (`-kclimit:`) defining a dummy value if the correction is not applied (`-kcdummy:`). The positions where the interpolation is performed are given in a text file for fixed position (`-points <file>`) or with position that changes in time (`-pointspos <file>`). Variables can be also computed at the position of existing particles with a given mk (`-particlesmk:`) or by indicating their id (`-particlesid:`). The distance of interpolation can be 2h (the size of the kernel) or can be changed (`-distinter_2h:`, `-distinter:`). The interpolation is carried out using a selected set of particles, so the same commands for PartVTK can be used (`-onlymk:`, `-onlyid:`, `-onlytype:`, `-onlypos:`, `-onlyposfile`). Different interpolated variables (`-vars`) can be numerically calculated; all available ones (`+/-all`), velocity (`+/-vel`), density (`+/-rhop`), pressure (`+/-press`), mass (`+/-mass`), volume (`+/-vol`), id (`+/-idp`), vorticity (`+/-vor`), acceleration (`+/-ace`) the summation of the kernel multiplied by volume (`+/-kcorr`), and variables defined by the user (`+/-XXX`). The maximum water depth can be also computed. Height values (`-height:`) are calculated according to the interpolated mass, if the nodal mass is higher than a given reference mass, that Z-position will be considered as the maximum height. The reference value can be calculated in relation to the mass values of the selected particles (`-height:0.5`, half the mass by default in 3D and `-height:0.4`  in 2D) or can be given in an absolute way (`-heightlimit:`).

As mentioned before, the positions where magnitudes will be computed are given in a text file for fixed position or with position that changes in time:
* fixed position using (`-points <file>`) and with a file needs to start with the key words POINTS or POINTSLIST:

<p align="center">
<img src="https://i.imgur.com/IZvS3sq.png" />
</p>

* position that changes in time using (`-pointspos <file>`) and the file should contain different lines with the position of the point of measurement.

As shown before there is a novel functionality in **BoundaryVTK** code that allows to create a CSV file with the positions of a moving point during the simulation. That CSV file can be used now with **MeasureTool** (`-pointspos file.csv`).

These points can be modified using a transformation matrix with displacement (MOVE), rotation (ROTATEAXIS) and scaling (SCALE). By default, the identity matrix is applied but using the following commands the matrix can be modified: 

<p align="center">
<img src="https://i.imgur.com/gtLPZRQ.png" />
</p>

More information can be found in MeasurTool4_Help.out in **doc/help**.

## 11.4 Force computation (ComputeForces)

The **ComputeForces** code is employed to compute the force exerted by the fluid onto a boundary object. The value of force is calculated as the summation of the acceleration values (solving the momentum equation) multiplied by the mass of each boundary particle (see also PostprocessingCalculations_v4.2.pdf). 

<p align="center">
<img src="https://i.imgur.com/MwiJ02f.png" />
</p>

<p align="center">
<strong>Figure 11-5.</strong> Input (red) and output (blue) files of ComputeForces code.
</p>

The momentum equation to solve the acceleration values is computed using the Wendland kernel. The distance of interpolation can be 2h (the size of the kernel) or can be changed (`-distinter_2h:`, `-distinter:`). The interpolation is carried out using a selected set of particles, so the same commands for PartVTK can be used (`-onlymk:`, `-onlyid:`, `-onlypos:`). The **output files** can be VTK-binary (`-savevtk`), CSV (`-savecsv`) or ASCII (`-saveascii`). 

Note that when computing forces exerted onto a floating body, only the buoyant force is calculated, so that the summation of the forces exerted by the surrounding fluid with the particles of the floating body. The total force exerted onto the floating body should be that buoyant force plus the weight of the object, but this weight is not included in the output results of **ComputeForces** with floating objects. 

More information can be found in _ComputeForces4_Help.out_ in **doc/help**.

## 11.5 Analysis of floating data (FloatingInfo)

The _FloatingInfo_ code is employed to obtain different data of the floating objects such as linear velocity, angular velocity, displacement of the center, motions and angles of rotation. The binary files (.bi4) generated by DualSPHysics and the file PartFloat.fbi4 are the **input files** of the **FloatingInfo** code and the **output files** are CSV files.

<p align="center">
<img src="https://i.imgur.com/riUel6V.png" />
</p>

<p align="center">
<strong>Figure 11-6.</strong> Input (red) and output (blue) files of FloatingInfo code.
</p>

By default, the code always saves time, fvel (linear velocity), fomega (angular velocity), center. Motions and rotation can be also obtained (`-savemotion`) in 2D (_surge, heave, roll_) and in 3D (_surge, sway, heave, roll, pitch, yaw_). A CSV file will be created with the information of each floating in the simulation, but user can choose a given floating object (`-onlymk:`) or the name of the file (`-savedata`).

More information can be found in FloatingInfo4_Help.out in **doc/help**.

## 11.6 Surface representation (IsoSurface)

Using a large number of particles, the visualization of the simulation can be improved by representing surfaces instead of particles. To create the surfaces, the _marching cubes_ algorithm is used [Lorensen and Cline, 1987]. This computer graphics technique extracts a polygonal mesh (set of triangles) of an isosurface from a 3-D scalar field. 

Figure 11-7, represents a 3-D dam-break simulation using 300,000 particles. The first snapshot shows the particle representation. Values of mass are interpolated at the nodes of a 3-D Cartesian mesh that covers the entire domain using an SPH interpolation. Thus a 3-D mesh vertex that belongs to the free surface can be identified. The triangles of this surface (generated by means of the marching cubes algorithm) are represented in the second frame of the figure. The last snapshots correspond to the surface representation where the colour corresponds to the interpolated velocity value of the triangles.

<p align="center">
<img src="https://i.imgur.com/cjrfEUR.png" />
</p>

<p align="center">
<strong>Figure 11-7.</strong> Conversion of points to surfaces.
</p>

The output binary files of DualSPHysics are the **input files** of the IsoSurface code and the **output files** are VTK files (`-saveiso[:<var>]`) with the isosurfaces calculated using a variable (`<var>`) or can be structured points (`-savegrid`) with data obtained after the interpolation. The Cartesian mesh size can be defined by specifying the discretisation size using either the particle size dp (`-distnode_dp:`) or by specifying an absolute internode distance (`-distnode:`). On the other hand, the maximum distance for the interaction between particles to interpolate values on the nodes can be also defined depending on 2h (`-distinter_dp:`) or in an absolute way (`-distinter:`). The particles to be considered to create the isosurface can be defined by the user using positions (`-onlypos` & `-onlyposfile`) or the limits of the isosurface can be indicated (`-iso_limits:`).

In addition, a useful option is to save a VTK file (polydata) with the slice of the isosurface (`-saveslice <file.vtk>`). The user can indicate how the vertices are processed to create the slice (`-slicedata:`). The plane of the slice can be also defined using a point and a vector (`-slicevec:ptx:pty:ptz:vecx:vecy:vecz`), or using three points (`-slice3pt:pt1x:pt1y:pt1z:pt2x:pt2y:pt2z:pt3x:pt3y:pt3z`).
This option can be interesting in 3-D tests, but it is very useful in 2D where contour lines of the fluid can be represented without plotting all fluid particles.

More information can be found in _IsoSurface4_Help.out_ in **doc/help**.

<p align="center">
<img src="https://i.imgur.com/QNKl1fc.png" />
</p>

<p align="center">
<strong>Figure 11-8.</strong> Input (red) and output (blue) files of IsoSurface code.
</p>

## 11.7 Flow computation (FlowTool)

The **FlowTool** code calculates the number of fluid particles that enters or leaves domains defined by the user. The average velocity of the particles that enters that domain since last output time is also computed. With the number of particles in the domain, the volume can be easily calculated by multiplying the volume of one particle by the number of particles. Therefore, the volume of fluid in some defined domains can be used to determine the inflow and outflow by dividing it with the interval time (output time). This post-processing tool is therefore very useful to compute discharges or overtopping in the case of coastal protection. 

The output binary files of DualSPHysics are the **input files** of the FlowTool code and **output files** can be VTK-binary (`-savevtk`) or CSV (`-savecsv`). The VTK (polydata) files contains the particles at the different domains and the CSV contains the number of particles that enters and leaves the domains (each specified by the user but also the entire system), the average velocity of those particles, the changes in volume and the inflow and outflow. 

<p align="center">
<img src="https://i.imgur.com/Py4QjYK.png" />
</p>

<p align="center">
<strong>Figure 11-9.</strong> Input (red) and output (blue) files of FlowTool code.
</p>

The domains are specified by the user (`-fileboxes`) using a text file where the 8 vertexes of a prism are defined:

<p align="center">
<img src="https://i.imgur.com/iCwbh0M.png" />
</p>

There is also an option to create a template file that helps the user (`-boxestemplate`).
More information can be found in _FlowTool4_Help.out_ in **doc/help**.

Figure 11-10 includes an example where three different prisms (the red, green and yellow domains) were defined. The discharge into the red box was computed (Figure 11-11) using the number of particles that enter the domain.

<p align="center">
<img src="https://i.imgur.com/6Dxi6YJ.png" />
</p>

<p align="center">
<strong>Figure 11-10.</strong> Prisms (the red, green and yellow domains) defined to use FlowTool code. 
</p>

<p align="center">
<img src="https://i.imgur.com/fgGW7PQ.png" />
</p>

<p align="center">
<strong>Figure 11-11.</strong> Time series of the discharge into the red prism.
</p>



